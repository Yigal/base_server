{
  "project": "Base Server Project Keypoints",
  "description": "Complete guidelines for building projects following the base_server template pattern",
  "version": "1.0.0",
  "sections": [
    {
      "id": 1,
      "name": "Configuration Management",
      "keypoints": [
        {
          "id": "1.1",
          "name": "config.json as Central Hub",
          "summary": "All server configuration should be defined in a single config.json file rather than hardcoding values throughout the application.",
          "description": "The `config.json` file is the single source of truth for all server configuration. Every route, external dependency, and port setting is defined here, eliminating hardcoded values. This approach ensures that the server can be deployed across different environments by simply changing the configuration file."
        },
        {
          "id": "1.2",
          "name": "Configuration Structure",
          "summary": "The config.json file must include run_details, external_dependencies, and api_details sections with specific nested properties.",
          "description": "The `config.json` must follow this structure:\n```json\n{\n  \"run_details\": {\n    \"root_port\": 8000,\n    \"local_storage_folder\": \"./storage\",\n    \"pid_file\": \"./storage/server.pid\",\n    \"docker_image\": \"my-server:latest\",\n    \"port_offsets\": {\n      \"dashboard\": 0,\n      \"api\": 1\n    }\n  },\n  \"external_dependencies\": {},\n  \"api_details\": {\n    \"routes\": {}\n  }\n}\n```"
        },
        {
          "id": "1.3",
          "name": "Port Offset System",
          "summary": "Services are accessed through a root_port plus configurable offsets (e.g., root_port 8000 for dashboard, 8001 for API).",
          "description": "Ports are managed through the `root_port` and `port_offsets` mechanism. The root_port (e.g., 8000) serves the dashboard, and offset ports serve other services. Adding 1 to root_port gives the API port (8001). This allows multiple services to coexist without port conflicts."
        },
        {
          "id": "1.4",
          "name": "Route Definition in Configuration",
          "summary": "Every API route must be explicitly registered in config.json with its HTTP method, function name, file path, inputs, and expected outputs.",
          "description": "Each route must be explicitly defined in `config.json` under `api_details.routes`. This includes the HTTP method, function name, file path, input parameters, and expected output structure. The Flask application automatically imports and registers these routes at startup."
        },
        {
          "id": "1.5",
          "name": "Environment Variables and .env",
          "summary": "Sensitive credentials like API keys must be stored in a .env file that is added to .gitignore to prevent accidental exposure.",
          "description": "Sensitive information like API keys and passwords must be stored in a `.env` file that is never committed to version control. The application loads these at runtime. Add `.env` to `.gitignore` to prevent accidental credential exposure."
        }
      ]
    },
    {
      "id": 2,
      "name": "BIST (Built-In Self Test) System",
      "keypoints": [
        {
          "id": "2.1",
          "name": "What is BIST?",
          "summary": "BIST is an automated testing framework that validates all endpoints, external dependencies, and dashboard pages are functional on server startup.",
          "description": "BIST is an automated testing framework that runs on server startup. It validates that all configured endpoints are functional, external dependencies are accessible, and the dashboard is operational. Results are saved to `results/bist_results.json` for inspection."
        },
        {
          "id": "2.2",
          "name": "BIST Execution Flow",
          "summary": "BIST runs automatically after the server starts, testing each endpoint defined in config.json and verifying external API connectivity.",
          "description": "When the server starts via `start.sh`, after the Docker container is running, BIST tests execute automatically. The tests probe each endpoint defined in `config.json`, verify external API connectivity, and check that all dashboard pages render correctly."
        },
        {
          "id": "2.3",
          "name": "BIST Test Results",
          "summary": "Test results are saved to results/bist_results.json containing endpoint status, response codes, success/failure flags, and dependency connectivity.",
          "description": "Test results are stored in `results/bist_results.json` with the following information:\n- Endpoint name and route\n- HTTP method used\n- Response status code\n- Response body\n- Test pass/fail status\n- Timestamp\n- External dependency connectivity status"
        },
        {
          "id": "2.4",
          "name": "Testing External Dependencies",
          "summary": "Each external API defined in config.json is tested to verify it's reachable and properly authenticated during BIST execution.",
          "description": "Each external API dependency defined in `config.json` under `external_dependencies` is tested during BIST. The system verifies that API endpoints are reachable and that any required authentication works before marking the dependency as healthy."
        },
        {
          "id": "2.5",
          "name": "Dashboard Page Validation",
          "summary": "BIST validates that all required dashboard pages exist and render without errors before marking the server as healthy.",
          "description": "The BIST framework validates that all dashboard pages (main.html, events.html, api_docs.html, etc.) exist and render without errors. If a required page is missing or has syntax errors, the test will flag it as failed."
        }
      ]
    },
    {
      "id": 3,
      "name": "Lifecycle Management (start.sh and stop.sh)",
      "keypoints": [
        {
          "id": "3.1",
          "name": "start.sh: Server Startup Process",
          "summary": "The start.sh script reads configuration, checks ports, builds the Docker image, runs the container, saves the PID, and executes BIST tests.",
          "description": "The `start.sh` script automates the entire startup process:\n1. Reads configuration from `config.json`\n2. Checks if the server is already running and stops it if necessary\n3. Verifies that required ports are available\n4. Builds the Docker image\n5. Runs the Docker container with proper port mapping and volume mounting\n6. Saves the container PID\n7. Runs BIST tests\n8. Displays the dashboard and API URLs"
        },
        {
          "id": "3.2",
          "name": "Port Configuration in start.sh",
          "summary": "The script dynamically extracts root_port and port_offsets from config.json to map container ports to the configured host ports.",
          "description": "The script extracts `root_port`, `port_offsets`, and `docker_image` from `config.json`. It maps the container's internal port 8000 to the configured root_port, and port 8001 (dashboard + 1) to root_port + 1. This allows changing server ports without modifying the script."
        },
        {
          "id": "3.3",
          "name": "Docker Integration",
          "summary": "The start.sh script builds a Docker image and runs it as a container with proper port mapping and volume mounting for persistent storage.",
          "description": "The `start.sh` script builds a Docker image using the `Dockerfile`, then runs it as a container. Volumes are mounted to persist storage data. The script ensures proper networking by mapping the internal container ports to the configured host ports."
        },
        {
          "id": "3.4",
          "name": "Health Checking",
          "summary": "After startup, the script waits for the container to initialize, retrieves its PID, and saves it for monitoring and shutdown purposes.",
          "description": "Before marking the server as started, `start.sh` waits 3 seconds for the container to initialize, then retrieves its PID and saves it to the file specified in `config.json`. This PID is used for monitoring and stopping the server."
        },
        {
          "id": "3.5",
          "name": "stop.sh: Server Shutdown Process",
          "summary": "The stop.sh script reads the PID file, stops and removes the Docker container, and cleans up related files.",
          "description": "The `stop.sh` script:\n1. Reads the PID file from `config.json` path\n2. Reads the container name from the Docker image name\n3. Stops the Docker container\n4. Removes the container\n5. Cleans up the PID file\n6. Verifies the port is freed before returning"
        },
        {
          "id": "3.6",
          "name": "Graceful Shutdown",
          "summary": "The shutdown process cleanly stops the container before removal, allowing for any necessary cleanup operations.",
          "description": "The shutdown process is designed to be graceful. The container is stopped cleanly (allowing for any necessary cleanup), then removed. If shutdown fails, the script reports an error and the PID file remains so the user is aware a process might still be running."
        }
      ]
    },
    {
      "id": 4,
      "name": "Pages and Dashboard Structure",
      "keypoints": [
        {
          "id": "4.1",
          "name": "Three-Page Dashboard System",
          "summary": "The server includes main.html for status, events.html for request logs, and api_docs.html for interactive API documentation.",
          "description": "The server includes three built-in dashboard pages accessible at `/ui/`:\n1. **main.html** - Server status, port information, configuration display\n2. **events.html** - Last 100 request/response logs with full details\n3. **api_docs.html** - Interactive API documentation with request builder"
        },
        {
          "id": "4.2",
          "name": "Dashboard Route Registration",
          "summary": "Dashboard routes are registered in ui/dashboard.py and map to template files in the templates/ directory.",
          "description": "The dashboard routes are registered in the Flask application via `ui/dashboard.py`. Each route maps to a template file. The templates are rendered from the `templates/` directory using Flask's template engine."
        },
        {
          "id": "4.3",
          "name": "Main Dashboard Page",
          "summary": "The main dashboard displays server name, port configuration, Docker image name, and links to other pages.",
          "description": "`main.html` displays:\n- Server name and version\n- Current port configuration (root_port and offsets)\n- Docker image name\n- Links to other dashboard pages\n- Configuration summary\n- Server uptime and status"
        },
        {
          "id": "4.4",
          "name": "Events Page",
          "summary": "The events page shows the last 100 API requests and responses with timestamps, methods, payloads, status codes, and success indicators.",
          "description": "`events.html` displays a log of the last 100 API requests and responses:\n- Timestamp of each request\n- Route and HTTP method\n- Full request payload\n- Full response body\n- HTTP status code\n- Success/failure indicator\n- Event logs can be exported or filtered by status"
        },
        {
          "id": "4.5",
          "name": "API Documentation Page",
          "summary": "The API docs page lists all endpoints with their methods, parameters, expected outputs, and provides an interactive request builder.",
          "description": "`api_docs.html` provides:\n- List of all configured endpoints\n- Method (GET, POST, PUT, DELETE, etc.)\n- Request input parameters with types\n- Expected output structure\n- Interactive request builder\n- Live response display\n- Automatic cURL command generation\n- Example requests"
        },
        {
          "id": "4.6",
          "name": "Template Extension",
          "summary": "Custom dashboard pages can be added by creating new HTML files in templates/ and registering routes in ui/dashboard.py.",
          "description": "Custom dashboard pages can be added by:\n1. Creating a new HTML file in `templates/`\n2. Registering a route in `ui/dashboard.py`\n3. Adding the template name to the dashboard navigation\nTemplates inherit from `base.html` for consistent styling and navigation."
        },
        {
          "id": "4.7",
          "name": "Static Files Organization",
          "summary": "CSS and JavaScript files are organized in static/ with separate folders for css/ and js/ serving as static assets.",
          "description": "CSS and JavaScript files are organized in `static/`:\n- `static/css/style.css` - Global styling\n- `static/js/` - JavaScript functionality\nThese files are served directly and referenced in templates."
        }
      ]
    },
    {
      "id": 5,
      "name": "Function Organization and Conventions",
      "keypoints": [
        {
          "id": "5.1",
          "name": "Three Function Types",
          "summary": "Functions are categorized as public (no prefix), private (_prefix), or dependency (dep_prefix) with specific rules for each type.",
          "description": "The project uses three distinct function types, each with specific rules:\n\n**Public Functions** (no prefix):\n- Called directly by Flask routes\n- Must have complete docstrings\n- Can only call private functions\n- Must return tuple: (dict/jsonify, status_code)\n\n**Private Functions** (`_` prefix):\n- Helper functions for public functions\n- Cannot be called by Flask\n- Used for internal logic and data processing\n- Return any type\n\n**Dependency Functions** (`dep_` prefix):\n- Call external APIs or services\n- Can access private functions\n- Can call other public functions\n- Handle authentication and error recovery"
        },
        {
          "id": "5.2",
          "name": "Function Documentation Format",
          "summary": "Every public function must include a docstring with description, return type, route_test block, and internal_dependencies block.",
          "description": "Every public function must include:\n- Description of what it does\n- Return type documentation\n- route_test block with test input/output\n- internal_dependencies block listing functions it calls\n\n```python\ndef my_function() -> tuple:\n    \"\"\"\n    Description of what this does.\n\n    Returns:\n        tuple: (response_dict, status_code)\n\n    route_test: {\n        \"route_test\": {\n            \"input\": {\"key\": \"value\"},\n            \"expected_output\": {\"success\": true}\n        }\n    }\n\n    internal_dependencies: {\n        \"internal_dependencies\": [\"_helper_function\"]\n    }\n    \"\"\"\n```"
        },
        {
          "id": "5.3",
          "name": "Response Format Standard",
          "summary": "All endpoints must return success responses with {\"success\": true, \"data\": ...} and error responses with {\"success\": false, \"error\": \"message\"}.",
          "description": "All endpoints must return responses in this format:\n\nSuccess response:\n```python\nreturn jsonify({\"success\": True, \"data\": {...}}), 200\n```\n\nError response:\n```python\nreturn jsonify({\"success\": False, \"error\": \"message\"}), 400\n```"
        },
        {
          "id": "5.4",
          "name": "Error Handling Pattern",
          "summary": "Every function must wrap logic in try-except blocks returning appropriate error responses with 500 status for unexpected errors.",
          "description": "Every public function must wrap its logic in try-except:\n```python\ntry:\n    data = request.get_json() if request.is_json else {}\n    # Process logic here\n    return jsonify({\"success\": True, \"data\": result}), 200\nexcept Exception as e:\n    return jsonify({\"success\": False, \"error\": str(e)}), 500\n```"
        },
        {
          "id": "5.5",
          "name": "Testing in Docstring",
          "summary": "The route_test block in docstrings specifies sample input data and expected output structure for BIST validation.",
          "description": "The `route_test` block in function docstrings specifies:\n- Sample input data\n- Expected output structure\n- This is parsed by BIST to validate the endpoint works correctly"
        },
        {
          "id": "5.6",
          "name": "Dependency Declaration",
          "summary": "The internal_dependencies block lists all functions called by the current function for call chain tracing and circular dependency detection.",
          "description": "The `internal_dependencies` block lists all functions called by this function:\n- Helps trace call chains\n- Used by BIST to understand dependencies\n- Enables circular dependency detection"
        }
      ]
    },
    {
      "id": 6,
      "name": "Event Logging System",
      "keypoints": [
        {
          "id": "6.1",
          "name": "Automatic Event Logging",
          "summary": "Every API request is automatically logged with timestamp, route, method, request/response data, status code, and execution time.",
          "description": "Every API request is automatically logged to `storage/events/` with the following information:\n- Timestamp (ISO 8601 format)\n- Route path\n- HTTP method\n- Request headers\n- Request body\n- Response headers\n- Response body\n- HTTP status code\n- Execution time (in milliseconds)\n- Success/failure flag"
        },
        {
          "id": "6.2",
          "name": "Event File Storage",
          "summary": "Events are stored as individual JSON files in storage/events/ with filenames formatted as TIMESTAMP_METHOD_ROUTE_STATUS.json.",
          "description": "Events are stored as individual JSON files in `storage/events/` with filenames like:\n```\n2024-01-31T14:30:45_POST_api_health_200.json\n```\n\nThe format is: `TIMESTAMP_METHOD_ROUTE_STATUS.json`"
        },
        {
          "id": "6.3",
          "name": "Retrieving Event Logs",
          "summary": "Event logs are displayed in the Events dashboard page showing the last 100 requests in reverse chronological order.",
          "description": "Event logs are displayed in the Events dashboard page (`/ui/events`). The dashboard fetches the last 100 events and displays them in reverse chronological order (newest first)."
        },
        {
          "id": "6.4",
          "name": "Event Data Structure",
          "summary": "Each event JSON contains timestamp, route, method, request headers/body, response status/headers/body, and execution time.",
          "description": "Each event JSON file contains:\n```json\n{\n  \"timestamp\": \"2024-01-31T14:30:45.123Z\",\n  \"route\": \"/api/health\",\n  \"method\": \"GET\",\n  \"request\": {\n    \"headers\": {},\n    \"body\": null,\n    \"query_params\": {}\n  },\n  \"response\": {\n    \"status_code\": 200,\n    \"headers\": {\"Content-Type\": \"application/json\"},\n    \"body\": {\"success\": true, \"status\": \"healthy\"}\n  },\n  \"execution_time_ms\": 12,\n  \"success\": true\n}\n```"
        },
        {
          "id": "6.5",
          "name": "Event Filtering and Search",
          "summary": "The Events page provides filtering by HTTP method, status code, route path, and success/failure status with CSV/JSON export options.",
          "description": "The Events page provides tools to:\n- Filter by HTTP method (GET, POST, etc.)\n- Filter by status code (200, 400, 500, etc.)\n- Search by route path\n- Filter by success/failure\n- Export events to CSV or JSON"
        }
      ]
    },
    {
      "id": 7,
      "name": "Docker Containerization",
      "keypoints": [
        {
          "id": "7.1",
          "name": "Dockerfile Structure",
          "summary": "The Dockerfile defines the base image, working directory, dependencies, exposed ports, and startup command.",
          "description": "The Dockerfile defines:\n- Base image (Python)\n- Working directory (/app)\n- Dependency installation\n- Port exposure (8000 and 8001)\n- Startup command (python app.py)"
        },
        {
          "id": "7.2",
          "name": "Image Naming Convention",
          "summary": "The Docker image is named in config.json using the format project-name:latest with the container name derived by appending _container.",
          "description": "The Docker image is named in `config.json` using the format:\n```\nproject-name:latest\n```\nThe container name is derived from the image name with `_container` suffix."
        },
        {
          "id": "7.3",
          "name": "Volume Mounting",
          "summary": "The start.sh script mounts the local storage/ folder to /app/storage allowing persistent event logs and easy host access.",
          "description": "The `start.sh` script mounts the local `storage/` folder to `/app/storage` in the container. This allows:\n- Persistent event logs\n- Access to server configuration from host\n- Easy debugging and log inspection"
        },
        {
          "id": "7.4",
          "name": "Port Mapping",
          "summary": "Docker maps container port 8000 to the configured root_port for the dashboard and port 8001 to root_port + 1 for the API.",
          "description": "Docker maps:\n- Container port 8000 → Host root_port (dashboard)\n- Container port 8001 → Host root_port + 1 (API)\n\nThis is configured in `start.sh` using values from `config.json`."
        },
        {
          "id": "7.5",
          "name": "Environment Variables in Container",
          "summary": "The Dockerfile can set default environment variables, and runtime variables from .env are made available to the Flask application.",
          "description": "The Dockerfile can include ENV instructions to set default values. Runtime environment variables from `.env` are made available to the Flask application through Python's `os.environ`."
        }
      ]
    },
    {
      "id": 8,
      "name": "Project Structure and File Organization",
      "keypoints": [
        {
          "id": "8.1",
          "name": "Modifiable vs Restricted Files",
          "summary": "Users modify config.json, functions/, requirements.txt, templates/, and .env but should not modify app.py, utils/, tests/, Dockerfile, or scripts.",
          "description": "**You will modify:**\n- `config.json` - Define routes and external dependencies\n- `functions/` - Write all API endpoint logic\n- `requirements.txt` - Add Python package dependencies\n- `templates/` - Customize dashboard HTML\n- `.env` - Store API keys and secrets\n\n**Do not modify:**\n- `app.py` - Core Flask application\n- `utils/` - Logging and configuration utilities\n- `tests/` - BIST testing framework\n- `Dockerfile` - Container configuration\n- `start.sh` / `stop.sh` - Lifecycle scripts"
        },
        {
          "id": "8.2",
          "name": "Directory Tree",
          "summary": "The project is organized with config at the root, user code in functions/ and templates/, internal code in utils/ and tests/, and runtime data in storage/.",
          "description": "```\nbase_server/\n├── config.json                  ← All configuration here\n├── requirements.txt             ← Python dependencies\n├── .env                        ← API keys (gitignored)\n├── .gitignore\n├── Dockerfile\n├── start.sh / stop.sh          ← Lifecycle scripts\n│\n├── app.py                      ← Main Flask application\n├── README.md / START_HERE.md\n│\n├── functions/                  ← Your endpoint code HERE\n│   └── health.py\n│\n├── ui/                         ← Dashboard routes\n│   └── dashboard.py\n│\n├── templates/                  ← Dashboard HTML\n│   ├── base.html\n│   ├── main.html\n│   ├── events.html\n│   ├── api_docs.html\n│   └── bist.html\n│\n├── static/                     ← CSS and JavaScript\n│   ├── css/style.css\n│   └── js/\n│\n├── utils/                      ← Internal utilities\n│   ├── config_loader.py\n│   └── event_logger.py\n│\n├── tests/                      ← BIST framework\n│   └── bist_runner.py\n│\n└── storage/                    ← Auto-created at runtime\n    ├── events/\n    └── server.pid\n```"
        }
      ]
    },
    {
      "id": 9,
      "name": "Adding New Endpoints",
      "keypoints": [
        {
          "id": "9.1",
          "name": "Complete Endpoint Addition Workflow",
          "summary": "Adding endpoints involves creating a function file, implementing the function, registering it in config.json, updating requirements.txt, and restarting.",
          "description": "Adding a new endpoint follows these steps:\n1. Create a function file in `functions/` (e.g., `functions/process.py`)\n2. Implement the function with correct format and documentation\n3. Register the route in `config.json` under `api_details.routes`\n4. Add any Python dependencies to `requirements.txt`\n5. Restart the server with `./start.sh`\n6. Verify BIST tests pass\n7. Test the endpoint via API docs page or curl"
        },
        {
          "id": "9.2",
          "name": "Function File Creation",
          "summary": "New endpoint files should be created in functions/ with the required function format, documentation, error handling, and return tuple.",
          "description": "Create a new file `functions/my_endpoint.py`:\n```python\nfrom flask import request, jsonify\n\ndef my_endpoint() -> tuple:\n    \"\"\"\n    Process user input and return result.\n\n    Returns:\n        tuple: (response_dict, status_code)\n\n    route_test: {\n        \"route_test\": {\n            \"input\": {\"data\": \"test\"},\n            \"expected_output\": {\"success\": true}\n        }\n    }\n\n    internal_dependencies: {\n        \"internal_dependencies\": []\n    }\n    \"\"\"\n    try:\n        data = request.get_json() if request.is_json else {}\n        # Your logic here\n        return jsonify({\"success\": True, \"data\": result}), 200\n    except Exception as e:\n        return jsonify({\"success\": False, \"error\": str(e)}), 500\n```"
        },
        {
          "id": "9.3",
          "name": "Configuration Registration",
          "summary": "Each route must be registered in config.json under api_details.routes with method, function name, file path, input parameters, and outputs.",
          "description": "Add to `config.json`:\n```json\n{\n  \"api_details\": {\n    \"routes\": {\n      \"my_route\": {\n        \"route\": \"/api/my-endpoint\",\n        \"method\": \"POST\",\n        \"function\": \"my_endpoint\",\n        \"function_file_relative_path\": \"functions/my_endpoint.py\",\n        \"input\": [\n          {\"data\": {\"type\": \"dict\", \"required\": true}}\n        ],\n        \"expected_output\": [\n          {\"result\": {\"type\": \"dict\", \"required\": true}}\n        ]\n      }\n    }\n  }\n}\n```"
        },
        {
          "id": "9.4",
          "name": "Testing New Endpoints",
          "summary": "After restarting, new endpoints appear in the API docs page and can be tested via the interactive builder or by checking event logs.",
          "description": "After restarting the server:\n1. Visit `/ui/api-docs` to see the new endpoint\n2. Use the interactive request builder to test\n3. Check `/ui/events` for request/response logs\n4. Verify BIST results in `results/bist_results.json`"
        }
      ]
    },
    {
      "id": 10,
      "name": "External API Integration",
      "keypoints": [
        {
          "id": "10.1",
          "name": "Integrating External Services",
          "summary": "External APIs are defined in config.json under external_dependencies with base URL, required headers, and timeout settings.",
          "description": "External APIs are defined in `config.json` under `external_dependencies`:\n```json\n{\n  \"external_dependencies\": {\n    \"openai\": {\n      \"base_url\": \"https://api.openai.com/v1\",\n      \"required_headers\": [\"Authorization\"],\n      \"timeout\": 30\n    }\n  }\n}\n```"
        },
        {
          "id": "10.2",
          "name": "Dependency Functions",
          "summary": "Create functions with dep_ prefix to call external APIs, and they should handle authentication, retries, and error recovery.",
          "description": "Create dependency functions with `dep_` prefix:\n```python\ndef dep_call_external_api(endpoint: str, method: str = \"GET\") -> dict:\n    \"\"\"Call external API, handles auth and retries.\"\"\"\n    auth_header = {\"Authorization\": f\"Bearer {os.environ.get('API_KEY')}\"}\n    # Implementation here\n    return response.json()\n```"
        },
        {
          "id": "10.3",
          "name": "Error Recovery in Dependencies",
          "summary": "Dependency functions should implement retry logic, timeout handling, auth error recovery, rate limiting awareness, and fallbacks.",
          "description": "Dependency functions should include:\n- Retry logic with exponential backoff\n- Timeout handling\n- Authentication error recovery\n- Rate limiting awareness\n- Fallback responses"
        },
        {
          "id": "10.4",
          "name": "Testing External Dependencies",
          "summary": "BIST automatically tests external dependencies by making test requests and verifying connectivity, authentication, and response status.",
          "description": "BIST automatically tests all external dependencies by:\n1. Making a test request to the base_url\n2. Verifying required headers are present\n3. Checking response status and timeout\n4. Recording results in `bist_results.json`"
        }
      ]
    },
    {
      "id": 11,
      "name": "Development and Deployment Workflow",
      "keypoints": [
        {
          "id": "11.1",
          "name": "Development Environment",
          "summary": "For local development without Docker, create a virtual environment, install requirements, and run python app.py directly.",
          "description": "For local development without Docker:\n```bash\npython -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\npython app.py\n```\n\nThe Flask app will run on the configured ports directly."
        },
        {
          "id": "11.2",
          "name": "Local Testing Workflow",
          "summary": "Development involves modifying code, updating config, restarting, testing via API docs, and reviewing event logs and BIST results.",
          "description": "1. Make code changes in `functions/`\n2. Update `config.json` if routes changed\n3. Restart with `./start.sh`\n4. Test via API docs (`/ui/api-docs`)\n5. Check logs at `/ui/events`\n6. Review BIST results"
        },
        {
          "id": "11.3",
          "name": "Production Checklist",
          "summary": "Before production deployment, verify all routes are configured, functions created, dependencies added, credentials set, and tests pass.",
          "description": "Before deploying to production:\n- [ ] All routes defined in `config.json`\n- [ ] All functions created and documented\n- [ ] All dependencies added to `requirements.txt`\n- [ ] All environment variables set in `.env`\n- [ ] BIST tests pass successfully\n- [ ] Event logging is working\n- [ ] Dashboard pages render correctly\n- [ ] External API integrations tested\n- [ ] Error handling implemented for all endpoints\n- [ ] Sensitive data removed from logs\n- [ ] Docker image tested locally"
        },
        {
          "id": "11.4",
          "name": "Deployment Steps",
          "summary": "Production deployment involves building the Docker image, tagging for the registry, pushing to registry, updating config, and running start.sh.",
          "description": "1. Build the Docker image: `docker build -t my-server:latest .`\n2. Tag for registry: `docker tag my-server:latest registry/my-server:latest`\n3. Push to registry: `docker push registry/my-server:latest`\n4. Update `config.json` with production image name\n5. Copy `.env` with production credentials\n6. Run `./start.sh` on production server"
        }
      ]
    },
    {
      "id": 12,
      "name": "Troubleshooting and Debugging",
      "keypoints": [
        {
          "id": "12.1",
          "name": "Common Issues and Solutions",
          "summary": "Common issues include port conflicts, missing config.json, function not found errors, and BIST failures, each with specific solutions.",
          "description": "**Port already in use:** Change `root_port` in `config.json` or kill the process using the port\n**config.json not found:** Ensure `config.json` is in the same directory as `start.sh`\n**Function not found:** Verify `function_file_relative_path` and function name in `config.json`\n**BIST tests failing:** Check `results/bist_results.json` for specific test failures"
        },
        {
          "id": "12.2",
          "name": "Debugging Techniques",
          "summary": "Debugging involves viewing container logs, accessing container shell, checking event logs, monitoring BIST results, or running locally.",
          "description": "1. View container logs: `docker logs my_server_container`\n2. Access container shell: `docker exec -it my_server_container bash`\n3. Check event logs: Browse `/ui/events` or read `storage/events/`\n4. Monitor BIST results: `cat results/bist_results.json | jq .`\n5. Run server locally: `python app.py` (no Docker)"
        },
        {
          "id": "12.3",
          "name": "Log Locations",
          "summary": "Flask logs appear in Docker container output, event logs in storage/events/, BIST results in results/bist_results.json, and PID in storage/server.pid.",
          "description": "- Flask logs: Docker container stdout (view with `docker logs`)\n- Event logs: `storage/events/` (JSON files)\n- BIST results: `results/bist_results.json`\n- Server PID: `storage/server.pid`"
        }
      ]
    },
    {
      "id": 13,
      "name": "Configuration Reference",
      "keypoints": [
        {
          "id": "13.1",
          "name": "Configuration Parameters",
          "summary": "Key configuration parameters include root_port, port_offsets, local_storage_folder, docker_image, and individual route properties.",
          "description": "| Parameter | Location | Purpose | Example |\n|-----------|----------|---------|----------|\n| root_port | run_details | Base port for dashboard | 8000 |\n| port_offsets | run_details | Service port increments | {\"api\": 1} |\n| local_storage_folder | run_details | Event logs directory | \"./storage\" |\n| docker_image | run_details | Image name and tag | \"my-server:latest\" |\n| route | api_details.routes | URL path | \"/api/health\" |\n| method | api_details.routes | HTTP method | \"GET\", \"POST\" |\n| function | api_details.routes | Function name | \"health_check\" |"
        },
        {
          "id": "13.2",
          "name": "Environment Variables",
          "summary": "Sensitive information like API_KEY, EXTERNAL_API_URL, and DATABASE_URL should be stored in .env files never committed to version control.",
          "description": "Store in `.env` (never commit):\n```\nAPI_KEY=sk-xxxxxxxxxxxx\nEXTERNAL_API_URL=https://api.example.com\nDATABASE_URL=postgresql://user:pass@host/db\n```\n\nLoad with: `os.environ.get('API_KEY')`"
        }
      ]
    },
    {
      "id": 14,
      "name": "Performance Optimization",
      "keypoints": [
        {
          "id": "14.1",
          "name": "Response Optimization",
          "summary": "Optimize responses by returning only necessary data, implementing pagination, caching frequently accessed data, and minimizing JSON payloads.",
          "description": "- Return only necessary data\n- Use pagination for large datasets\n- Cache frequently accessed data\n- Minimize JSON payload size"
        },
        {
          "id": "14.2",
          "name": "Scaling Considerations",
          "summary": "For scaling, use connection pooling, implement rate limiting, consider load balancing, and monitor response times via event logs.",
          "description": "- Use connection pooling for databases\n- Implement request rate limiting\n- Consider load balancing for multiple containers\n- Monitor response times via event logs"
        }
      ]
    },
    {
      "id": 15,
      "name": "Security Best Practices",
      "keypoints": [
        {
          "id": "15.1",
          "name": "Credential Management",
          "summary": "Never hardcode credentials, use .env files, add .env to .gitignore, rotate credentials regularly, and maintain environment-specific configs.",
          "description": "- Never hardcode API keys\n- Use `.env` file for all secrets\n- Add `.env` to `.gitignore`\n- Rotate credentials regularly\n- Use environment-specific configuration"
        },
        {
          "id": "15.2",
          "name": "Input Validation",
          "summary": "Validate all request parameters, use type hints, check request.is_json, and return 400 Bad Request for invalid inputs.",
          "description": "- Validate all request parameters\n- Use type hints for clarity\n- Check request.is_json before accessing data\n- Return 400 Bad Request for invalid input"
        },
        {
          "id": "15.3",
          "name": "Output Sanitization",
          "summary": "Avoid exposing internal error details, log full errors internally while returning generic messages, and remove sensitive data from logs.",
          "description": "- Don't expose internal error details\n- Log full errors internally, return generic messages\n- Avoid exposing system paths or file locations\n- Remove sensitive data from event logs"
        }
      ]
    }
  ]
}
